"smds assembly language"

// example this:

any myfunc(x) = x^2 + 2*x + 1;
vec2[] points = [(1,2), (3,4), (5,6)];
triangle(myfunc(points) + 1);

// would be compiled to:

; FUNCTIONS

// inputs and outputs. Even though this is declared as "any", this acts basically like c++ templates.
// if this were also called on a number at some point there would be a separate FUNC0_NUM version of this function generated (and this one would be FUNC0_VVEC2)
FUNC0: ; f
	IN0: VVEC2
	OUT: VVEC2

FUNC0_VARS:
	VAR0: VVEC2

FUNC0_BEGIN:
	VS_POW IN0 2: OUT
	VS_MUL IN0 2: VAR0
	VV_ADD OUT VAR0: OUT
	VS_ADD OUT 1: OUT
	RET

; PREALLOC
points: STATIC VVEC2 3 // the actual array of vec2s. this is static because the values are known at compile time

// func#_type_call#
FUNC0_RET_0: VVEC2 3 // the space to write the return values of FUNC0 when called on points

// output buffer, this is only written to, and rendered from by js outside of wasm.
// sometimes this will need to be another actual allocation, but a lot you can just reuse the return buffer of the last function call since
// triangle() doesnt actually do anything with its input other than read it.
POLY_BUF0: VVEC2 3

// opcode param1 param2: dest
; PROGRAM
CALL FUNC0 points: FUNC0_RET_0
VS_ADD FUNC0_RET_0 1: POLY_BUF0

; END

// end of the program
This assembly is simd first, so it uses an unusual memory model.
Here, the working memory would be laid out like this:
[points (static, taken directly from instantiation)][FUNC0_RET_0][FUNC0_ALLOC0_0][POLY_BUF0]

Data is written destructivly, as variables cannot be reassigned, like in functional programming.
This lets us avoid all runtime allocation. This isnt the most efficient use of memory, but it is designed to be
parallelizable and fast to compute.

Once the program executes, the POLY_BUF0 memory can be read out to get the final result of the triangle() call and rendered to the canvas.

dasm can be compiled into wasm, and eventually into something like x86 machine code, or gpu shaders via spir-v and cuda.
There are several instructions, like VS_ADD which is vector-scalar add, and VV_ADD which is vector-vector add.

A more complex .smd example:

// Simple Example
vec2[] points = [(1,2), (3,4), (5,6)];

any myfunc(any x) {
    any n = x + 3;
    any b = x^2;
    return x^2 + 2*x + 1) / (n + b);
}

uniform int size = 5;
$color: black;
vec2[] grid = for (x: [0...size], y: [0...size]) {
    (x, y);
}

vec2[] points_aaa = switch {
    grid.x > 0: [(0,0)],
    grid.y > 0: [(0,0)],
    [(1,1)]
}

triangle(myfunc(points))

uniforms are variables that can be changed at runtime from the UI, and are essentially treated as static during execution,
but are updated between frames without needing to recompile the entire program.

Things can be declared as any, this is basically like a mix of templates for functions and the auto keyword in c++.
The # denotes a "folder", and is mostly just a way to group things together. private and public keywords control visibility of functions and variables.
In smds technically everything is globally scoped, but here private folders can be locally scoped, but this would just be essentiually a macro
that prepends the folder id to everything inside of it to avoid name collisions, still compiled the same way.

$ if for formatting, ignored for assembly.